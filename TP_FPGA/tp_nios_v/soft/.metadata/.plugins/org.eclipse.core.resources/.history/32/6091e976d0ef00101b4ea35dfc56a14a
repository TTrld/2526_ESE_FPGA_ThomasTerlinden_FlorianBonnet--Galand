#include <stdio.h>
#include <unistd.h>
#include "system.h"
#include "altera_avalon_pio_regs.h"
#include "altera_avalon_i2c.h"

// --- Constantes ---
#define ADXL345_I2C_ADDR    0x53 
#define REG_DEVID           0x00
#define REG_POWER_CTL       0x2D
#define REG_DATAX0          0x32

ALT_AVALON_I2C_DEV_t *i2c_dev;

// Fonction d'écriture simple (pour la configuration)
void adxl_write(uint8_t reg, uint8_t value) {
    uint8_t tx_buffer[2];
    tx_buffer[0] = reg;
    tx_buffer[1] = value;
    
    // On utilise master_tx car on envoie juste des données sans attendre de réponse
    alt_avalon_i2c_master_tx(i2c_dev, tx_buffer, 2, ALT_AVALON_I2C_NO_INTERRUPTS);
}

// Fonction de lecture des 3 axes (X, Y, Z) en utilisant tx_rx
void adxl_read_xyz(int16_t *x, int16_t *y, int16_t *z) {
    uint8_t tx_buffer[1];
    uint8_t rx_buffer[6]; // On lit 6 octets (X0, X1, Y0, Y1, Z0, Z1)

    tx_buffer[0] = REG_DATAX0; // Adresse de départ

    // Cette fonction fait : Start -> Envoi REG -> Repeated Start -> Lecture 6 octets -> Stop
    alt_avalon_i2c_master_tx_rx(i2c_dev,
                                tx_buffer, 1,
                                rx_buffer, 6,
                                ALT_AVALON_I2C_NO_INTERRUPTS);

    // Reconstitution selon votre consigne
    *x = (int16_t)((rx_buffer[1] << 8) | rx_buffer[0]);
    *y = (int16_t)((rx_buffer[3] << 8) | rx_buffer[2]);
    *z = (int16_t)((rx_buffer[5] << 8) | rx_buffer[4]);
}

int main(void) {
    printf("Demarrage du Niveau a Bulles (ADXL345)...\n");

    // 1. Ouverture du driver
    i2c_dev = alt_avalon_i2c_open(I2C_0_NAME);
    if (!i2c_dev) {
        printf("Erreur: Impossible d'ouvrir l'I2C.\n");
        return -1;
    }

    // 2. IMPORTANT : Définir l'adresse cible (l'accéléromètre)
    // C'est ce qui manquait dans votre code précédent !
    alt_avalon_i2c_master_target_set(i2c_dev, ADXL345_I2C_ADDR);

    // 3. Vérification de la connexion (Optionnel mais recommandé)
    uint8_t devid_reg = REG_DEVID;
    uint8_t devid_val = 0;
    alt_avalon_i2c_master_tx_rx(i2c_dev, &devid_reg, 1, &devid_val, 1, ALT_AVALON_I2C_NO_INTERRUPTS);
    
    if (devid_val != 0xE5) {
        printf("Erreur ID: Lu 0x%02X au lieu de 0xE5. Verifiez le cablage.\n", devid_val);
    } else {
        printf("ADXL345 detecte avec succes.\n");
    }

    // 4. Configuration : Sortie de veille
    // Ecriture de '1' dans le bit Measure (Bit 3) -> 0x08
    adxl_write(REG_POWER_CTL, 0x08);

    int16_t x, y, z;
    uint16_t led_pattern;
    int led_index;

    while (1) {
        // Lecture des accélérations
        adxl_read_xyz(&x, &y, &z);
        
        // Debug
        // printf("X=%d Y=%d Z=%d\n", x, y, z);

        // --- Logique d'affichage (Axe X uniquement pour la barre de LED) ---
        // x vaut environ 0 à plat.
        // Division par 32 pour réduire la sensibilité (ajuster selon besoin)
        led_index = 5 + (x / 32);

        // Bornage pour ne pas sortir des 10 LEDs (0 à 9)
        if (led_index < 0) led_index = 0;
        if (led_index > 9) led_index = 9;

        // Allumage de la LED correspondante (1 décalé de l'index)
        led_pattern = (1 << led_index);

        IOWR_ALTERA_AVALON_PIO_DATA(PIO_0_BASE, led_pattern);

        usleep(50000); // 50ms
    }

    return 0;
}
